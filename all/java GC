一、对象 存活判断
  1、引用计数
    缺点: 无法解决对象相互循环引用的问题
    新生代 用
  2、可达性分析:
    从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。
    (使用中的对象会被 以下 对象引用)
    GC Roots包括:
        1、虚拟机栈中引用的对象。
        2、方法区中类静态属性实体引用的对象。
        3、方法区中常量引用的对象。
        4、本地方法栈中JNI引用的对象。

    老年代用

    3、引用类别
        java里面有四种应用关系，从强到弱分别为：
        Strong Reference（强引用) –>Weak Reference (弱引用） -> Soft Reference（软引用） – > Phantom Reference（引用）
            Strong Reference ： 只有在引用对象root不可达的情况下才会标识为可回收，垃圾回收才可能进行回收
            Soft Reference ： 无论其引用的对象是否root可达，在响应内存需要时，由垃圾回收判断是否需要回收。
            Weak Reference ：用来描述非必需对象。即使在root算法中 其引用的对象root可达到，只能生存到下一次垃圾回收之前。
            Phantom Reference ：无法通过虚引用获得一个对象的实例，设置虚引用的目的就是能在这个对象被收集器回收时收到一个系统通知。


二、垃圾手机算法
    1、“标记-清除”（Mark-Sweep）算法
        缺点:
            1、一个是效率问题，标记和清除过程的效率都不高
            2、标记清除之后会产生大量不连续的内存碎片
    2、复制”（Copying）的收集算法
        它将可用内存按容量划分为大小相等的两块, 复制存活, 清理全部
        缺点:
            1、将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低
            2、复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低

    3、标记-整理 算法
        老年代: 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

    4、分代收集算法
        GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短
        把Java堆分为新生代和老年代
        4.1、新生代: 每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法
        4.2、老年代: 对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。


三、垃圾收集器
    1、Serial收集器(串行收集器)
        最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
        新生代、老年代使用串行回收；新生代复制算法、老年代标记-整理；垃圾收集的过程中会Stop The World（服务暂停）
        新生代串行，老年代串行；新生代复制算法、老年代标记-整理

    2、ParNew 收集器(Serial的多线程版本)
        新生代并行，老年代串行；新生代复制算法、老年代标记-整理

    3、Parallel 收集器(类似 ParNew)
        关注系统的吞吐量
        以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；
        新生代并行，老年代串行；新生代复制算法、老年代标记-整理

    4、Parallel Old 收集器
        Parallel 的 老年代 多线程 版本
        这个收集器是在JDK 1.6中才开始提供
        新生代并行，老年代并行；新生代复制算法、老年代标记-整理

    5、CMS(Concurrent Mark Sweep）收集器
        标记-清除
        以获取最短回收停顿时间为目标
            1、初始标记（CMS initial mark） -> GC Roots  stop
            2、并发标记（CMS concurrent mark） -> GC Roots Tracing     时间长
            3、重新标记（CMS remark）   -> 修正并发标记  stop
            4、并发清除（CMS concurrent sweep）-> 时间长

        新生代复制算法、老年代 标记-清除

        其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。
        初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

        优点:并发收集、低停顿
        缺点：产生大量空间碎片、并发阶段会降低吞吐量

        参数控制：-XX:+UseConcMarkSweepGC  使用CMS收集器
                -XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
                -XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理
                -XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）

    6、G1收集器
        替换掉JDK1.5中发布的CMS收集器
        与CMS收集器相比G1收集器有以下特点:
            1、空间整合，G1收集器采用标记整理算法
            2、可预测停顿，这是G1的另一大优势, G1除了追求低停顿外，还能建立可预测的停顿时间模型

        新生代复制算法、老年代 标记-整理

        它将整个Java堆划分为多个大小相等的独立区域（Region）,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合
        G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿

        收集步骤：
            1、标记阶段 -> 初始标记  停顿  Mintor GC
            2、Root Region Scanning ->  回收survivor区(存活到老年代)，这一过程必须在young GC之前完成
            3、Concurrent Marking ->  在整个堆中进行并发标记
            4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾
            5、Copy/Clean up，多线程清除失活对象, G1将回收区域的存活对象拷贝到新区域
            6、复制/清除过程后


三、java 内存模型
    1、工作内存 和 主内存
    2、逻辑内存模型
        2.0、 类文件-> 类装载子系统
        2.1、 运行期数据区: 方法区(所有线程共享)、 java堆(所有线程共享)、 java虚拟机栈(线程私有)、 程序计数器(线程私有)、本地方法栈
        2.2、执行引擎、 本地方法接口


       java 虚拟机栈: 用于存储局部变量表、操作栈、动态链接、方法出口等信息。 虚拟机栈为虚拟机执行Java 方法
       java方法区: 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据


四、内存溢出和内存泄漏的区别?你在工作中遇到过什么情况,怎么解决的?  GC 调优


五、G1 和GMS 的区别
    与CMS收集器相比G1收集器有以下特点:
        1、空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片
        2、可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型

        3、 其他收集器 收集的范围都是整个新生代或者老年代; 但是 而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），
            虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合
        4、G1的新生代收集跟ParNew(新生代复制算法)类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。
